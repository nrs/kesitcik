

#include "pr1.h"
#include "prgl.h"
#include "glutMaster.h"
#include "glutWindow.h"
#include <fstream>
GlutMaster  * glutMaster;
MeshWindow  * firstWindow = 0;

using namespace std;

std::list<mesh> single_rein(Real width, Real height, unsigned int count, Real rad, Real dprime);

void lolfun( std::list<mesh> &m );
vector<Real> lol2(mesh &m);


vector<Real> project2nodes( mesh &m, std::vector<Real> &vec);

int main(int argc, char** argv) {
  std::cout << "Generating random mesh" << std::endl;
  
  glutMaster   = new GlutMaster();    
  
  firstWindow  = new MeshWindow(glutMaster,
                                700, 700,    // height, width
                                0, 0,    // initPosition (x,y)
                                "Poot"); // title

/*  
  mesh m1,m2;

  rectangular_section(m1,-150,150,500,0);
  Real center[] = {80,80}; circular_section(m2,8,center,12);

  m1.subtract(m2);

  m1.print_info();
  m1.triangulate_mesh(0.1);
*/
  std::list<mesh> m = single_rein(300,500,5,8,80);
  lolfun(m);
  firstWindow->add_mesh(m);
//  firstWindow->glmesh.push_back(&m.front());
//  m[0].print_info();
  firstWindow->init();
//  constitutive::concrete1 a;
//  std::cout << "ADADADASdAS " << a << std::endl;
  glutMaster->CallGlutMainLoop();

}


std::list<mesh> single_rein(Real width, Real height, unsigned int count, Real rad, Real dprime){
  int nsides=12;
  std::list<mesh> m(1);
  std::list<mesh> rein(count);
  std::list<mesh>::iterator mesh_it ;
  unsigned int i;
  Real center[2];
  rectangular_section(m.front(),-1*width/2,width/2,height,0);

  i=0;
  for (mesh_it = rein.begin(); mesh_it != rein.end(); mesh_it++,i++){
    center[0]=-1*width/2 + (i+1)*width/(count+1) ;
    center[1]=dprime;
    circular_section(*mesh_it,rad,center,nsides);

  }


  // for (unsigned int i=0; i<count; i++){
  //   center[0]=-1*width/2 + (i+1)*width/(count+1) ;
  //   center[1]=dprime;
  //   circular_section(rein[i],rad,center,nsides);
  // }
//  Real center[] = {80,80}; circular_section(m2,8,center,12);
  for (mesh_it = rein.begin(); mesh_it != rein.end(); mesh_it++){
    m.front().subtract(*mesh_it);
  }

  m.front().triangulate_mesh(50);

//  std::list<node>::iterator node_it;
  // for (node_it=m[0].holes.begin(); node_it != m[0].holes.end(); node_it++){
  //   std::cout << *node_it;
  //   std::cout<<std::endl;
  // }

  m.push_back(mesh());
  for (mesh_it = rein.begin(); mesh_it != rein.end(); mesh_it++){
    m.back().add(*mesh_it);
  }
  m.back().triangulate_mesh(5);

  m.front().mat = new constitutive::concrete1;
  m.back().mat = new constitutive::steel1;
  m.front().print_info(); 
  cout<<endl;
  m.back().print_info();

  return m;
}


void lolfun( std::list<mesh> &m ){

  list<mesh>::iterator mesh_it;
  vector<vector<Real> > luli;
  // for (mesh_it = m.begin(); mesh_it != m.end(); mesh_it++)
  //   mesh_it->init_node2tri();


//  std::cout << m.front().mat->sig(0.00001) << std::endl;
  

  std::vector<Real> sig, eps;

  eps = numtk::range(-4e-3,4e-3,1000);
  for (unsigned int i=0; i<eps.size();i++)
    sig.push_back(  m.front().mat->sig(eps[i]) );

  numtk::output_gp(eps,sig,"lolfile.txt");
  node a(0,2);
  std::cout << numtk::distance(a,0.3,1) << std::endl;


  for (mesh_it = m.begin(); mesh_it != m.end(); mesh_it++){
    vector<Real> dum=lol2(*mesh_it);
    luli.push_back(project2nodes(*mesh_it,dum));
    
  }
  
  for (vector<vector<Real> >::iterator vec_it = luli.begin(); 
       vec_it != luli.end(); vec_it++){
    for (vector<Real>::iterator it = vec_it->begin();
         it != vec_it->end(); it++){
//      cout<< *it << endl;
    }
  }

  out_vtk1(m,luli);
//  for (unsigned int i=0; i<eps.size();i++)  std::cout << eps[i] << std::endl;;
//  }
//  catch (...) {
//    std::cout << "LOL" <<std::endl;
//  }
//  m.back().print_info();


}

std::vector<Real> lol2(mesh &m){
  std::list<triangle>::iterator tri_it;
  std::vector<Real> result;
  Real dum;
  for (tri_it = m.triangles.begin(); tri_it!=m.triangles.end(); tri_it++){
    dum = m.mat->sig( -0.00001* ( (*(*tri_it).cent)(1) - 200) );
//    dum = 0.001;
//    cout << m.mat->description << endl;
    result.push_back(dum);
//    cout<< result.back() << endl;
  }
  
  return result;
}


std::vector<Real> project2nodes( mesh &m, std::vector<Real> &vec){
  m.init_node2tri();
  m.numbernodes();
  std::vector<Real> result;
  std::list<node>::iterator node_it;
  std::set<triangle*>::iterator tri_it;
  if (vec.size() != m.centroids.size()) {
    std::cerr << "Projection on nodes unsuccessful." << std::endl;
    return result;
  }
//  cout<< vec.back()<<endl;

  Real dum;
  for (node_it = m.nodes.begin(); node_it!=m.nodes.end(); node_it++){
    dum=0;
    for (tri_it = m.node2tri[&(*node_it)].begin(); 
         tri_it != m.node2tri[&(*node_it)].end();
         tri_it++){
      dum+=vec[(*tri_it)->id];
//      cout << vec[(*tri_it)->id] <<endl;
    }
    if (m.node2tri[&(*node_it)].size() != 0){
      dum /= (Real) m.node2tri[&(*node_it)].size();
    }
//    dum+=node2tri[&(*node_it)];
    result.push_back(dum);
//    cout<< result.back() << endl;
  }
  return result;

}
